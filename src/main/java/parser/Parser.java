package parser;

import java.util.LinkedList;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Set;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.util.Stack;

import ds.token.Token;
import ds.token.TokenType;

import exceptions.SourceException;

public class Parser
{
    private LinkedList<Token> tokens;
    private HashMap<String, Integer> functionLineNumbers;
    private final Set<String> reservedWords;

    public Parser(LinkedList<Token> tokens)
    {
        this.tokens = tokens;
        this.functionLineNumbers = new HashMap<>();
        this.reservedWords = Stream.of("fn", "break", "continue",
                                       "do", "return", "fn",
                                       "var", "end", "while",
                                       "if", "elsif", "else")
                                   .collect(Collectors.toUnmodifiableSet());
    }

    public void parse()
    {
        System.out.println("Generated Bytecode");
        System.out.println("==================");

        try {
            System.out.println(this.generateBytecode());            
        } catch (SourceException se) {
            System.out.println(se.getMessage());
        }
    }

    private String generateBytecode() throws SourceException
    {
        StringBuilder bytecodeBuilder = new StringBuilder();
        StringBuilder functionBytecodeBuilder = new StringBuilder();
        HashMap<String, Integer> localFuncVariableMapping = new HashMap<>();
        int functionLineNumber = 0;
        int numUnclosedBlocks = 0;
        Iterator<Token> tokenIter = this.tokens.iterator();
        while (tokenIter.hasNext()) {
            Token token = tokenIter.next();
            if (token.getType() == TokenType.FUNCTION_DECLARATION) {
                // TODO: Raise an error if a function is declared inside a
                //       function. We are not supporting that feature in this
                //       language.

                // Get the function name and compute its line numbers
                // in the generated bytecode. For readability purposes,
                // a line will divide two functions and a function and the
                // metadata from each other. This is why we increment
                // functionLineNumber by 2.
                int functionBytecodeCharNum = functionBytecodeBuilder.length();
                functionBytecodeBuilder.delete(0, functionBytecodeCharNum);
                functionBytecodeBuilder.append("\n\n");

                localFuncVariableMapping.clear();

                functionLineNumber += 2;

                // TODO: Check if the function name is a reserved word or not.
                //       Raise an error if it is the case.

                this.functionLineNumbers.put(tokenIter.next()
                                                      .getValue(),
                                             new Integer(functionLineNumber));

                numUnclosedBlocks++;

                // Remember that in function declarations, arguments are
                // placed inside parentheses and should immediately be after
                // the function name.
                token = tokenIter.next();
                if (!token.getValue().equals("(")) {
                    int tokenLine = token.getStartingLine();
                    int tokenColumn = token.getStartingColumn();

                    throw new SourceException("'(' should immediately "
                                              + "succeed the function name.",
                                              tokenLine,
                                              tokenColumn);
                }

                // We initially expect a parameter because we expect that
                // immediately after the first parenthesis of the argument
                // block is a parameter.
                boolean isParameterExpected = true;

                // The arguments to the function are passed, actually pushed,
                // to the stack in the order they are positioned in the function
                // declaration arguments. We're using a stack to store the
                // initial parameter bytecodes to store the arguments to the
                // correct variable addresses (i.e. the first argument should
                // be stored in the function variable address 0, the second
                // argument should be stored in address 1, and so on). We
                // can simply store the arguments in reverse order (i.e. the
                // last argument will be stored in variable address 0, etc.).
                // However, we are not doing this to make debugging the
                // bytecode easier.
                Stack<String> parameterBytecodes = new Stack<>();
                while (!(token = tokenIter.next()).getValue()
                                                  .equals(")")) {
                    // Since we're dealing with parsing the function
                    // declaration, we can assume that there will only be one
                    // closing parenthesis. It's a violation of Cube syntax
                    // rules (and weird in most languages) that there will be
                    // more than parentheses in the function arguments.
                    if (isParameterExpected) {
                        if (token.getType() != TokenType.USER_DEFINED_SYMBOL) {
                            int tokenLine = token.getStartingLine();
                            int tokenColumn = token.getStartingColumn();

                            throw new SourceException("Expected a symbol. "
                                                      + "Got something else.",
                                                      tokenLine,
                                                      tokenColumn);
                        } else {
                            String parameterName = token.getValue();
                            int parameterAddr = localFuncVariableMapping.size();
                            
                            localFuncVariableMapping.put(parameterName,
                                                         parameterAddr);

                            String parameterBytecode;
                            parameterBytecode = String.format("    STORE %d\n",
                                                              parameterAddr);
                            
                            parameterBytecodes.push(parameterBytecode);
                        }
                    } else {
                        if (!token.getValue().equals(",")) {
                            int tokenLine = token.getStartingLine();
                            int tokenColumn = token.getStartingColumn();

                            throw new SourceException("Expected a comma.",
                                                      tokenLine,
                                                      tokenColumn);
                        }
                    }

                    isParameterExpected = !isParameterExpected;
                }

                while (!parameterBytecodes.isEmpty()) {
                    String parameterBytecode = parameterBytecodes.pop();
                    functionBytecodeBuilder.append(parameterBytecode);
                }
            } else if (token.getType() == TokenType.END_KEYWORD) {
                numUnclosedBlocks--;

                if (numUnclosedBlocks == 0) {
                    // Assuming the syntax and semantics in the code are
                    // correct, this means that we reached the end of the
                    // function.
                    bytecodeBuilder.append(functionBytecodeBuilder.toString());
                }
            }
        }

        return bytecodeBuilder.toString();
    }
}